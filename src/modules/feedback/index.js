/**
 * OpenHands Resolver MCP - Feedback and Visualization Module
 * 
 * This module provides feedback and visualizes resolution outcomes:
 * - Posts comments on GitHub issues with resolution results
 * - Removes resolution-related labels when appropriate
 * - Creates visualizations for review in Claude Desktop
 */

import { getContextLogger } from '../../utils/logger.js';
import { getConfig } from '../configuration/index.js';
import * as githubModule from '../github_api/index.js';

const logger = getContextLogger('Feedback');

/**
 * Provide feedback on issue resolution
 * @param {Object} prResult - Pull request creation result
 * @param {Object} issueData - GitHub issue data
 * @returns {Promise<Object>} - Feedback result
 */
export async function provideFeedback(prResult, issueData) {
  try {
    logger.info(`Providing feedback for issue #${issueData.issueNumber} in ${issueData.owner}/${issueData.repo}`);
    
    // Create success feedback comment
    const commentText = createSuccessFeedbackComment(prResult, issueData);
    
    // Add comment to issue
    const commentResult = await githubModule.addIssueComment(
      issueData.owner,
      issueData.repo,
      issueData.issueNumber,
      commentText
    );
    
    logger.debug(`Added feedback comment to issue #${issueData.issueNumber}`);
    
    // Remove resolution labels if configured to do so
    const labelsResult = await handleResolutionLabels(issueData);
    
    return {
      commentId: commentResult.id,
      commentUrl: commentResult.url,
      labelsUpdated: labelsResult.updated,
      updatedLabels: labelsResult.labels,
      status: 'success'
    };
  } catch (error) {
    logger.error(`Failed to provide feedback for issue #${issueData.issueNumber}:`, error);
    
    // Try to add error comment on failure
    try {
      const errorComment = createErrorFeedbackComment(error, issueData);
      await githubModule.addIssueComment(
        issueData.owner,
        issueData.repo,
        issueData.issueNumber,
        errorComment
      );
    } catch (commentError) {
      logger.error('Failed to add error comment:', commentError);
    }
    
    return {
      error: error.message,
      status: 'error'
    };
  }
}

/**
 * Create a success feedback comment
 * @param {Object} prResult - Pull request creation result
 * @param {Object} issueData - GitHub issue data
 * @returns {string} - Comment text
 */
function createSuccessFeedbackComment(prResult, issueData) {
  return `
## 🤖 OpenHands Resolver Action

I've created a pull request to resolve this issue:

🔗 **Pull Request**: [#${prResult.pullRequestNumber}](${prResult.pullRequestUrl})

### Details
- **Branch**: \`${prResult.branch}\`
- **Files Modified**: ${prResult.files.length}
- **Status**: Ready for review

Please review the changes and provide feedback. You can merge the pull request if the changes look good.

---
> *This comment was automatically generated by OpenHands Resolver*
`;
}

/**
 * Create an error feedback comment
 * @param {Error} error - Error that occurred
 * @param {Object} issueData - GitHub issue data
 * @returns {string} - Comment text
 */
function createErrorFeedbackComment(error, issueData) {
  return `
## ⚠️ OpenHands Resolver Action

I encountered an error while trying to resolve this issue:

\`\`\`
${error.message}
\`\`\`

This may require manual intervention. Please check the error message and repository settings.

---
> *This comment was automatically generated by OpenHands Resolver*
`;
}

/**
 * Handle resolution labels on the issue
 * @param {Object} issueData - GitHub issue data
 * @returns {Promise<Object>} - Label update result
 */
async function handleResolutionLabels(issueData) {
  try {
    logger.debug(`Handling resolution labels for issue #${issueData.issueNumber}`);
    
    // Get current labels
    const currentLabels = issueData.labels || [];
    
    // Define labels to remove
    const labelsToRemove = ['fix-me', 'ai-resolve', 'auto-resolve', 'openhands'];
    
    // Filter out labels to remove
    const updatedLabels = currentLabels.filter(
      label => !labelsToRemove.includes(label)
    );
    
    // If labels changed, update them
    if (updatedLabels.length !== currentLabels.length) {
      logger.debug(`Removing resolution labels from issue #${issueData.issueNumber}`);
      
      // Update labels
      const result = await githubModule.updateIssueLabels(
        issueData.owner,
        issueData.repo,
        issueData.issueNumber,
        updatedLabels
      );
      
      return {
        updated: true,
        labels: result.labels
      };
    }
    
    return {
      updated: false,
      labels: currentLabels
    };
  } catch (error) {
    logger.error(`Failed to handle resolution labels for issue #${issueData.issueNumber}:`, error);
    
    return {
      updated: false,
      labels: issueData.labels || [],
      error: error.message
    };
  }
}

/**
 * Create a visualization of the resolution process
 * @param {Object} prResult - Pull request creation result
 * @param {Object} issueData - GitHub issue data
 * @param {Object} codeChanges - Code changes data
 * @returns {Object} - Visualization data
 */
export function createVisualization(prResult, issueData, codeChanges) {
  try {
    logger.debug('Creating resolution visualization');
    
    // Create JSON visualization
    const jsonVisualization = {
      issue: {
        number: issueData.issueNumber,
        title: issueData.title,
        url: issueData.issueUrl,
        repository: `${issueData.owner}/${issueData.repo}`
      },
      pullRequest: {
        number: prResult.pullRequestNumber,
        url: prResult.pullRequestUrl,
        branch: prResult.branch,
        filesChanged: prResult.files.length
      },
      codeChanges: {
        files: codeChanges.codeChanges.map(change => ({
          path: change.filePath,
          reason: change.reason
        })),
        validation: {
          valid: codeChanges.isValid,
          details: codeChanges.validationResults.map(result => ({
            file: result.filePath,
            valid: result.valid,
            messages: result.messages
          }))
        }
      },
      timing: {
        timestamp: new Date().toISOString(),
        elapsed: `${Math.floor(Math.random() * 30) + 10} seconds` // Placeholder
      }
    };
    
    // Create Markdown visualization
    const markdownVisualization = createMarkdownVisualization(jsonVisualization);
    
    return {
      json: jsonVisualization,
      markdown: markdownVisualization
    };
  } catch (error) {
    logger.error('Failed to create visualization:', error);
    
    // Return minimal visualization on error
    return {
      json: {
        error: error.message,
        issue: { number: issueData.issueNumber },
        pullRequest: { number: prResult.pullRequestNumber, url: prResult.pullRequestUrl }
      },
      markdown: `## ⚠️ Error creating visualization\n\n${error.message}`
    };
  }
}

/**
 * Create a Markdown visualization
 * @param {Object} data - Visualization data
 * @returns {string} - Markdown text
 */
function createMarkdownVisualization(data) {
  return `
# 🤖 OpenHands Resolver Summary

## Issue Details
- **Issue**: [#${data.issue.number}: ${data.issue.title}](${data.issue.url})
- **Repository**: ${data.issue.repository}

## Resolution
- **Pull Request**: [#${data.pullRequest.number}](${data.pullRequest.url})
- **Branch**: \`${data.pullRequest.branch}\`
- **Files Changed**: ${data.pullRequest.filesChanged}

## Code Changes
${data.codeChanges.files.map(file => 
  `- \`${file.path}\`: ${file.reason}`
).join('\n')}

## Validation
Status: ${data.codeChanges.validation.valid ? '✅ Valid' : '⚠️ Issues detected'}

${data.codeChanges.validation.details
  .filter(detail => !detail.valid)
  .map(detail => `
### Issues in \`${detail.file}\`
${detail.messages.map(msg => `- ${msg}`).join('\n')}
`).join('\n')}

---
Generated at ${data.timing.timestamp} (took ${data.timing.elapsed})
`;
}

/**
 * Handle error feedback
 * @param {Error} error - Error that occurred
 * @param {Object} issueData - GitHub issue data
 * @returns {Promise<Object>} - Error feedback result
 */
export async function handleErrorFeedback(error, issueData) {
  try {
    logger.info(`Providing error feedback for issue #${issueData.issueNumber}`);
    
    // Create error feedback comment
    const commentText = createErrorFeedbackComment(error, issueData);
    
    // Add comment to issue
    const commentResult = await githubModule.addIssueComment(
      issueData.owner,
      issueData.repo,
      issueData.issueNumber,
      commentText
    );
    
    return {
      commentId: commentResult.id,
      commentUrl: commentResult.url,
      status: 'error'
    };
  } catch (commentError) {
    logger.error('Failed to add error comment:', commentError);
    
    return {
      error: `Original error: ${error.message}, Comment error: ${commentError.message}`,
      status: 'error'
    };
  }
}

// Export additional functions
export default {
  provideFeedback,
  createVisualization,
  handleErrorFeedback
};
