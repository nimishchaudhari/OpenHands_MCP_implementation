/**
 * Feedback and Visualization Module
 * Provides resolution feedback and visualizes outcomes
 */

const logger = require('../../utils/logger');
const githubApi = require('../github_api');
const configModule = require('../configuration');

/**
 * Provide feedback on the resolution process
 * @param {Object} prResult - Pull request creation result
 * @param {Object} issueData - Data about the GitHub issue
 * @returns {Promise<Object>} - Feedback result
 */
async function provideFeedback(prResult, issueData) {
  try {
    logger.info(`Providing feedback for issue #${issueData.number}`);
    
    // Generate feedback comment
    const comment = generateFeedbackComment(prResult, issueData);
    
    // Post comment to the issue
    const commentResult = await postIssueComment(comment, issueData);
    
    // Remove "fix-me" label if it exists
    await removeFixMeLabel(issueData);
    
    logger.info(`Posted feedback comment to issue #${issueData.number}`);
    
    return {
      commentId: commentResult.id,
      commentUrl: commentResult.url,
      feedback: comment
    };
  } catch (error) {
    logger.error(`Failed to provide feedback for issue #${issueData.number}:`, error);
    // Don't throw error here, as this is a non-critical part of the process
    return {
      error: error.message,
      success: false
    };
  }
}

/**
 * Generate a feedback comment
 * @private
 * @param {Object} prResult - Pull request creation result
 * @param {Object} issueData - Data about the GitHub issue
 * @returns {string} - Feedback comment
 */
function generateFeedbackComment(prResult, issueData) {
  const { pullRequestNumber, pullRequestUrl, branch } = prResult;
  
  return `## ðŸ¤– OpenHands Resolver

I've created a pull request addressing this issue:

**ðŸ”— [Pull Request #${pullRequestNumber}](${pullRequestUrl})**

The changes were implemented in the branch \`${branch}\`. 

### What's Next?

1. Please review the pull request to ensure it addresses the issue correctly
2. Request changes or provide feedback if needed
3. Merge the pull request when satisfied with the solution

### Resolution Process

This solution was automatically generated by the OpenHands Resolver MCP, which:
1. Analyzed the issue description and context
2. Generated code changes to resolve the issue
3. Created a pull request with the proposed solution

Let me know if you need any clarification or have any questions about the solution!`;
}

/**
 * Post a comment to a GitHub issue
 * @private
 * @param {string} comment - Comment to post
 * @param {Object} issueData - Data about the GitHub issue
 * @returns {Promise<Object>} - Comment result
 */
async function postIssueComment(comment, issueData) {
  try {
    // In a real implementation, this would use the GitHub API to post a comment
    // For this MVP, we'll simulate the response
    
    logger.info(`Posting comment to issue #${issueData.number}`);
    
    // Simulate a successful comment posting
    return {
      id: Math.floor(Math.random() * 1000000),
      url: `${issueData.url}#comment-12345`,
      body: comment,
      created_at: new Date().toISOString()
    };
  } catch (error) {
    logger.error(`Failed to post comment to issue #${issueData.number}:`, error);
    throw new Error(`Failed to post issue comment: ${error.message}`);
  }
}

/**
 * Remove the "fix-me" label from an issue
 * @private
 * @param {Object} issueData - Data about the GitHub issue
 * @returns {Promise<boolean>} - Success status
 */
async function removeFixMeLabel(issueData) {
  try {
    const { owner, repo, number, labels } = issueData;
    
    // Check if "fix-me" label exists
    if (!labels.includes('fix-me')) {
      logger.debug(`Issue #${number} does not have the "fix-me" label, no need to remove`);
      return true;
    }
    
    logger.info(`Removing "fix-me" label from issue #${number}`);
    
    // In a real implementation, this would use the GitHub API to remove the label
    // For this MVP, we'll simulate the response
    
    // Simulate a successful label removal
    return true;
  } catch (error) {
    logger.error(`Failed to remove "fix-me" label from issue #${issueData.number}:`, error);
    return false;
  }
}

/**
 * Create a visualization of the resolution process
 * @param {Object} prResult - Pull request creation result
 * @param {Object} issueData - Data about the GitHub issue
 * @param {Object} codeChanges - Generated code changes
 * @returns {Object} - Visualization data
 */
function createVisualization(prResult, issueData, codeChanges) {
  // For this MVP, we'll create a simple JSON visualization
  // In a real implementation, this could generate more complex visualizations
  
  const visualizationData = {
    issue: {
      number: issueData.number,
      title: issueData.title,
      url: issueData.url,
      repository: `${issueData.owner}/${issueData.repo}`
    },
    pullRequest: {
      number: prResult.pullRequestNumber,
      url: prResult.pullRequestUrl,
      branch: prResult.branch
    },
    codeChanges: {
      filesChanged: codeChanges.codeChanges.length,
      changes: codeChanges.codeChanges.map(change => ({
        path: change.path,
        // Include only the first 100 characters of content for brevity
        contentPreview: change.content.substring(0, 100) + (change.content.length > 100 ? '...' : '')
      }))
    },
    timeline: {
      resolved: new Date().toISOString(),
      resolutionTime: '00:05:23' // Simulated resolution time
    }
  };
  
  logger.debug('Created visualization data for issue resolution');
  
  return visualizationData;
}

/**
 * Format visualization data as HTML
 * @param {Object} visualizationData - Visualization data
 * @returns {string} - HTML representation
 */
function formatVisualizationAsHtml(visualizationData) {
  return `
<!DOCTYPE html>
<html>
<head>
  <title>Issue Resolution Visualization</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    h1 { color: #24292e; }
    .card { border: 1px solid #e1e4e8; border-radius: 6px; padding: 16px; margin-bottom: 16px; }
    .card h2 { margin-top: 0; color: #0366d6; }
    .file-change { background-color: #f6f8fa; padding: 8px; border-radius: 4px; margin-bottom: 8px; }
    .file-path { font-weight: bold; color: #24292e; }
    .preview { font-family: monospace; white-space: pre-wrap; }
    .timeline { display: flex; justify-content: space-between; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Issue Resolution Visualization</h1>
  
  <div class="card">
    <h2>Issue</h2>
    <p><strong>#${visualizationData.issue.number}:</strong> ${visualizationData.issue.title}</p>
    <p><a href="${visualizationData.issue.url}" target="_blank">View on GitHub</a></p>
    <p><strong>Repository:</strong> ${visualizationData.issue.repository}</p>
  </div>
  
  <div class="card">
    <h2>Pull Request</h2>
    <p><strong>#${visualizationData.pullRequest.number}</strong></p>
    <p><a href="${visualizationData.pullRequest.url}" target="_blank">View on GitHub</a></p>
    <p><strong>Branch:</strong> ${visualizationData.pullRequest.branch}</p>
  </div>
  
  <div class="card">
    <h2>Code Changes</h2>
    <p><strong>Files Changed:</strong> ${visualizationData.codeChanges.filesChanged}</p>
    
    ${visualizationData.codeChanges.changes.map(change => `
      <div class="file-change">
        <div class="file-path">${change.path}</div>
        <div class="preview">${change.contentPreview}</div>
      </div>
    `).join('')}
  </div>
  
  <div class="card">
    <h2>Timeline</h2>
    <div class="timeline">
      <div>
        <strong>Resolved:</strong> ${new Date(visualizationData.timeline.resolved).toLocaleString()}
      </div>
      <div>
        <strong>Resolution Time:</strong> ${visualizationData.timeline.resolutionTime}
      </div>
    </div>
  </div>
</body>
</html>
  `;
}

/**
 * Format visualization data as JSON
 * @param {Object} visualizationData - Visualization data
 * @returns {string} - JSON representation
 */
function formatVisualizationAsJson(visualizationData) {
  return JSON.stringify(visualizationData, null, 2);
}

module.exports = {
  provideFeedback,
  createVisualization,
  formatVisualizationAsHtml,
  formatVisualizationAsJson
};